#' Extract part coefficients from DCV ridge regression model
#'
#' Takes a set of logratio coefficients from a DiCoVar logistic regression model
#' and extracts the coefficients for the individual parts in those logratios.
#'
#' @param mdl Logistic regression model generated by DiCoVar
#' @param s Lambda penalty parameter to use when retrieving model coefficients
#'
#' @return A tibble containing the coefficients for each part in the model.
#'
#' @importFrom rlang .data
#' @export
#'
extract_ridge_coefficients <- function(mdl, s = "lambda.min") {
  # grab model coefficients at optimal lambda
  cc <- tibble::as_tibble(as.matrix(glmnet::coef.glmnet(mdl, s = s)), rownames = "Ratio")

  # Imp = absolute coefficient, raw = original coefficient
  keyRats <- cc %>%
    dplyr::slice(-1) %>%
    dplyr::mutate(Raw = .data$lambda.min, Imp = abs(.data$lambda.min)) %>%
    dplyr::select(-.data$lambda.min) %>%
    tidyr::separate(col = .data$Ratio, into = c("Num", "Denom"), sep = "___", remove = FALSE)

  ## stack ratio for consistent interpretation
  keyRats2 = keyRats
  keyRats2$Num = keyRats$Denom
  keyRats2$Denom= keyRats$Num
  keyRats2$Ratio= paste0(keyRats$Denom, "___", keyRats$Num)
  keyRats2$Raw = -keyRats$Raw
  # mark original ratio orientation
  keyRats$Orientation = "original"
  keyRats2$Orientation = "inverted"
  keyRats2 = rbind(keyRats, keyRats2)
  ### keep negative edges (more abundance more likely in control outcome)
  keyRats = dplyr::filter(keyRats2, .data$Raw < 0)

  ## Define weight such that:  weight * log(a/b) = weight * log(a) - weight * log(b)
  weights.df <- dplyr::bind_rows(dplyr::transmute(keyRats, Part = .data$Num,
                                                  Coef = .data$Raw),
                                 dplyr::transmute(keyRats, Part = .data$Denom,
                                                  Coef = -1*.data$Raw)) %>%
    dplyr::group_by(.data$Part) %>%
    dplyr::summarise(Coef = sum(.data$Coef))

  return(weights.df)
}
